/*
solvers[Token.Pointer] = function (this, CTP, pointers): void {
    this.updateCursor()

    if (this.currToken.type !== Token.Identifier) {
        throw new Error('Expected identifier after pointer')
    }

    const pointerName = this.currToken.value as string

    this.updateCursor()

    if (
        [
            Token.Attribute, Token.Macro, Token.Identifier
        ].includes(this.currToken.type) === false
    ) {
        throw new Error('Expected attribute, macro or identifier after pointer')
    }

    let finished = false

    const chields = reader.call(this, function (this: Scope, CTP) {        
        if (finished === true) return false

        if (
            [
                Token.Attribute, Token.Macro, Token.Identifier, Token.OpenScope
            ].includes(this.content[this.cursor + 1]?.type)
        ) return false

        if (this.currToken.type !== Token.Identifier) {
            return false
        }

        pointers[pointerName] = CTP as ConcreteParserTree

        return false
    })

    CTP.childrens = chields
}

solvers[Token.Reference] = function (this, CTP, pointers): void {
    this.updateCursor()

    if (this.currToken.type !== Token.Identifier) {
        throw new Error('Expected identifier after reference')
    }

    const pointerName = this.currToken.value as string

    if (pointers[pointerName] === undefined) {
        throw new Error(`Unknown pointer ${pointerName}`)
    }

    let firstTime = true

    reader.call(this, function (this: Scope, CTP) {
        if (firstTime === false) return false

        const prev = structuredClone(CTP)

        const ref = pointers[pointerName]



        return false
    })
}
*/
/*
solvers[Token.Attribute] = function (this, CTP, _pointers): void {
    if (CTP.attributes === undefined) CTP.attributes = {}

    this.updateCursor()

    if (this.currToken.type !== Token.Identifier) {
        throw new Error('Expected identifier after attribute name')
    }
    
    const attrName = this.currToken.value as string

    this.updateCursor()

    // @ts-ignore - TypeScript thinks this.currToken.type is a Identifier but it'll be a String
    if (this.currToken.type !== Token.String) {
        throw new Error('Expected string after attribute name')
    }

    CTP.attributes[attrName] = this.currToken.value as string
}

solvers[Token.Identifier] = function (this, CTP, _pointers): void {
    CTP.name = this.currToken.value as string
    this.updateCursor()

    CTP.childrens = reader.call(this)
}*/
/*
function reader(this: Scope, done?: Done): ConcreteParserTree[] {
    const contentLength = this.content.length

    const concreteSyntaxTree: Partial<ConcreteParserTree> = {}
    const pointers: Record<string, ConcreteParserTree> = {}

    while (this.cursor < contentLength) {
        this.currToken = this.content[this.cursor]

        solvers[this.currToken.type]?.call(this, concreteSyntaxTree, pointers)

        if (done?.call(this, concreteSyntaxTree) === true) break

        this.cursor++
    }

    return concreteSyntaxTree as ConcreteParserTree[]
}*/
/*
const getChildByIndent = (indent: number, CTP: ConcreteParserTree[]): ConcreteParserTree | undefined => {
    if (indent === 0) return CTP.at(-1)

    const child = CTP.at(-1)?.childrens.at(-1)

    if (child === undefined) return undefined

    return getChildByIndent(indent - 1, child.childrens)
}*/

solvers[Token.Identifier] = function (this): void {
    

    /*this.updateCursor()

    if (
        [Token.Attribute, Token.Identifier].includes(this.currToken.type)
    ) {
        const chields = reader.call(this, function (this: Scope) {
            if (
                [Token.Attribute, Token.Identifier].includes(this.currToken.type)
            ) return false

            return true
        })

        this.concreteParserTree.at(-1)!.childrens = chields
    } */
}


/*
solvers[Token.EndLine] = function (this): void {
    this.updateCursor()
    this.tabs = 0

    while (
        this.cursor < this.content.length &&
        this.currToken.type === Token.Tab
    ) {
        this.updateCursor()
        this.tabs++
    }

}

solvers[Token.Tab] = function (this: Scope, CTP): void {
    this.updateCursor()

    if (
        this.currToken.type === Token.EndLine
    ) return

    console.log(1, this.currToken)

    const tabs = this.tabs

    const chields = reader.call(this, function (this: Scope) {
        if (
            this.cursor >= this.content.length
        ) return true

        if (
            [Token.EndLine, Token.Tab].includes(this.currToken.type)
        ) return false

        if (tabs <= this.tabs) return false

        return true
    })

    console.log(chields)

    const child = getChildByIndent(tabs, this.concreteParserTree.at(-1)!)

    if (child === null) {
        this.concreteParserTree.at(-1)!.childrens = chields
    }

    else {
        child.childrens = chields
    }

}
*/


// - - - 
/*const text = "a\n\tb\n\t\tc\n\td";

interface Node {
	value: string;
	children?: Node[];
}

function parse(input: string): Node {
	const lines = input.split("\n");

	const rootNode: Node = { value: "", children: [] };
	const stack: Node[] = [rootNode];

	for (const line of lines) {
		const indentation = line.search(/\S/);
		const newNode: Node = { value: line.trim() };

		while (indentation !== stack.length - 1) {
			stack.pop();
		}

		const parentNode = stack[stack.length - 1];
		if (!parentNode.children) {
			parentNode.children = [];
		}
		parentNode.children.push(newNode);

		stack.push(newNode);
	}

	return rootNode.children![0];
}

console.log(parse(text))*/

// - - -
/*import { Token } from "./src/@types/lexer.ts";
import { lexer } from "./src/handlers/lexer.ts";

const r_1 = lexer(`a
\tb
	\tc
\td
`);

console.log(r_1);
*/
// - - -

/*interface Node {
	value: string;
	children?: Node[];
}

function parse(input: string): Node {
	const lines = input.split("\n");

	const rootNode: Node = { value: "", children: [] };
	const stack: Node[] = [rootNode];

	for (const line of lines) {
		const indentation = line.search(/\S/);
		const newNode: Node = { value: line.trim() };

		while (indentation !== stack.length - 1) {
			stack.pop();
		}

		const parentNode = stack[stack.length - 1];
		if (!parentNode.children) {
			parentNode.children = [];
		}
		parentNode.children.push(newNode);

		stack.push(newNode);
	}

	return rootNode.children![0];
}
const text = "a\n\tb\n\t\tc\n\td";

const r_2 = parse(text);

console.log(r_2);*/
/*
import { Token } from "./src/@types/lexer.ts";
import { lexer } from "./src/handlers/lexer.ts";

const r_1 = lexer(`a\n
\tb\n
\t\tc\n
\td\n
`);

console.log(r_1);

interface Node {
	name: string;
	children?: Node[];
}

function parse(tokens: Token[]): Node {
	let root: Node = { name: '', children: [] };
	let stack: Node[] = [root];
	let indentLevel = 0;
	let currentName = '';

	for (const token of tokens) {
		if (token.type === Token.EndLine) { // EndLine token
			const parent = stack[stack.length - 1];
			const node = { name: currentName };

			if (!parent.children) {
				parent.children = [];
			}

			parent.children.push(node);
			stack.push(node);
			currentName = '';
			indentLevel = 0;
		} else if (token.type === Token.Tab) { // Tab token
			indentLevel++;
		} else { // Name token
			if (indentLevel < stack.length - 1) {
				while (indentLevel < stack.length - 1) {
					stack.pop();
				}
			}

			const parent = stack[stack.length - 1];
			const node = { name: currentName };

			if (!parent.children) {
				parent.children = [];
			}

			parent.children.push(node);
			stack.push(node);
			currentName = token.value as string;
		}
	}

	return root.children![0];
}

// Example usage
let root = parse(r_1);
console.log(root);
*/

import { Token } from "./src/@types/lexer.ts";
import { lexer } from "./src/handlers/lexer.ts";

const file = await Deno.readTextFile("./test.tm");
console.log(`${file}`)

const r_1 = lexer(file);


/*
function parseTokens(tokens: any[]): Node {
  const stack: Node[] = [];
  let currentIndentationLevel = 0;
 
  for (let i = 0; i < tokens.length; i++) {
	const token = tokens[i];
 
	if (token.type === 6) { // Nodo
	  const node = { name: token.value, children: [] };
	  const parentNode = stack[stack.length - 1];
 
	  if (parentNode) {
		parentNode.children.push(node);
	  } else {
		stack.push(node);
	  }
	} else if (token.type === 9) { // Tab
	  currentIndentationLevel++;
	} else if (token.type === 8) { // Fin de línea
	  const nextToken = tokens[i + 1];
 
	  if (nextToken && nextToken.type === 9) { // Cambio de nivel de indentación
		currentIndentationLevel++;
		stack.push(stack[stack.length - 1].children[stack[stack.length - 1].children.length - 1]);
	  } else { // Misma indentación
		currentIndentationLevel--;
		stack.pop();
	  }
	}
  }
 
  return stack[0];
}
*/
/*
function parseTokens(tokens: Token[]): Node {
	const root: Node = { name: tokens[0].value as string, children: [] };
	let current = root;

	for (let i = 1; i < tokens.length; i++) {
		const token = tokens[i];

		if (token.type === 9) { // Tab
			current = current.children[current.children.length - 1];
		} else if (token.type === 8) { // EndLine
			current = root;
		} else if (token.type === 6) { // Node
			const node: Node = { name: token.value as string, children: [] };
			current.children.push(node);
			current = node;
		}
	}

	return root;
}

const r_2 = parseTokens(r_1);
console.log(r_2);
console.log(r_2.children)

const tokens = [
	{ type: 6, value: "a", pos: { start: 0, end: 1 } },
	{ type: 8, value: null, pos: { start: 2, end: 3 } },
	{ type: 9, value: null, pos: { start: 3, end: 4 } },
	{ type: 6, value: "b", pos: { start: 4, end: 5 } },
	{ type: 8, value: null, pos: { start: 6, end: 7 } },
	{ type: 9, value: null, pos: { start: 7, end: 8 } },
	{ type: 9, value: null, pos: { start: 8, end: 9 } },
	{ type: 6, value: "c", pos: { start: 9, end: 10 } },
	{ type: 8, value: null, pos: { start: 11, end: 12 } },
	{ type: 9, value: null, pos: { start: 12, end: 13 } },
	{ type: 6, value: "d", pos: { start: 13, end: 14 } },
	{ type: 8, value: null, pos: { start: 15, end: 16 } }
];

const root = parseTokens(tokens);
console.log(root);
*/

type Node = {
	name: string;
	children: Node[];
	parent?: Node;
};

enum TokenType {
	Node = 6,
	EndLine = 8,
	Tab = 9,
}

function parse(tokens: Token[]): Node[] {
	const rootNode: Node = { name: '', children: [] };
	let currentNode: Node = rootNode;
	let lastTabCount = 0;

	for (const token of tokens) {
		switch (token.type) {
			case TokenType.Node:
				const newNode: Node = { name: token.value as string, children: [] };
				currentNode.children.push(newNode);
				currentNode = newNode;
				break;

			case TokenType.EndLine:
				currentNode = rootNode;
				lastTabCount = 0;
				break;

			case TokenType.Tab:
				const currentTabCount = (token.value as string).length;
				if (currentTabCount > lastTabCount) {
					currentNode = currentNode.children[currentNode.children.length - 1];
				} else if (currentTabCount < lastTabCount) {
					let diff = lastTabCount - currentTabCount;
					while (diff--) {
						currentNode = currentNode.parent!;
					}
				}
				lastTabCount = currentTabCount;
				break;

			default:
				throw new Error(`Unexpected token type: ${token.type}`);
		}
	}

	return rootNode.children;
}


const r_2 = parse(r_1);
console.log(r_2);
