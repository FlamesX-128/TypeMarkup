import { Node, NodeElement, TokenElement } from "TypeMarkup";

import * as color from "https://deno.land/std@0.185.0/fmt/colors.ts";

class Scope<T> {
    public readonly contentSize: number
    public readonly content: T[]

    public currElement?: T
    public cursor = 0

    constructor(
        content: T[] = []
    ) {

        this.contentSize = content.length
        this.content = content

        this.currElement = content[0]
    }

    public inRange(): boolean {
        return this.cursor < this.content.length
    }

    public next(): boolean {
        this.currElement = this.content[++this.cursor]

        return this.inRange()
    }

    public prev(): boolean {
        this.currElement = this.content[--this.cursor]

        return this.inRange()
    }

}

const singletonTags = [
    'area',
    'base',
    'br',
    'col',
    'embed',
    'hr',
    'img',
    'input',
    'link',
    'meta',
    'param',
    'source',
    'track',
    'wbr'
];

class ParserScope extends Scope<TokenElement> {
    public analyzers: Record<string, (this: ParserScope) => void> = {}
    public readonly values: NodeElement[] = []
    public readonly file: string

    public attributes: Record<string, string | null> | null = null
    public indent = 0

    public referenceName: string | null = null
    public referenceDef: string | null = null

    constructor(
        content: TokenElement[] = [], file: string
    ) {
        super(content)
        this.file = file
    }

    getLastNodeById(nodes: NodeElement[], referenceName: string | null): NodeElement | null {
        for (const node of nodes) {
            console.log(node.id)

            if (node.id === referenceName) return node

            if (node.childNodes !== null)
                return this.getLastNodeById(node.childNodes, referenceName)

            if (node.childNode !== null)
                return this.getLastNodeById([node.childNode], referenceName)

        }

        return null
    }

    assignLastNodeByLevel(
        nodes: NodeElement[], indent: number, value: NodeElement, referenceName: string | null
    ): NodeElement {
        const node: NodeElement | undefined = nodes[nodes.length - 1]

        if (node !== undefined && node.childNode !== null && node.indent <= indent)
            return this.assignLastNodeByLevel([node.childNode], indent, value, referenceName)

        if (node === undefined && indent !== 0) {
            /*this.invalidElement(
                'error', 'An incorrect level of tabulation has been detected in the code.',
                this.currElement!.pos
            )*/

            console.log(color.red('An incorrect level of tabulation has been detected in the code.'))

            return value
        }

        if (indent === 0) {
            nodes.push(value)
            return value
        }

        if (node.childNodes === null) node.childNodes = []

        return this.assignLastNodeByLevel(node.childNodes, indent - 1, value, referenceName)
    }

    assignNodeAttributes(node: NodeElement) {
        if (
            node.nodeType === Node.Text && this.attributes !== null
        ) this.invalidAttributeOnTextNode(node)

        node.attributes = { ...this.attributes || {} }
        this.attributes = null
    }

    assignNodeId(node: NodeElement) {
        node.id = this.referenceDef
        this.referenceDef = null
    }

    // - - -
    invalidElement(type: 'error' | 'warning', message: string, pos: any) {
        /*let EOL_1 = pos.start - 1
        let EOL_2 = -1

        for (let i = pos.start; i >= 0; i--) {
            if (this.file[i] !== '\n') continue

            EOL_1 = i
            break
        }

        for (let i = pos.end!; i <= this.file.length; i++) {
            if (this.file[i] !== '\n') continue

            EOL_2 = i
            break
        }

        const colorType = type === 'error' ? color.red : color.yellow

        console.log(
            colorType(type) + `: ${message}\n`
            + `  ${pos.start} -> ` + color.underline(`${this.file.slice(EOL_1 + 1, EOL_2).replaceAll('\t', '')}\n`)
        )*/
    }

    invalidAttributeOnTextNode(node: NodeElement) {
        //this.invalidElement('warning', 'Unexpected attribute on text node.', node.pos)
    }
}

class LexerScope {
    public readonly contentSize: number
    public readonly content: string

    public currElement?: string
    public cursor = 0

    public readonly data: TokenElement[] = []

    public rows: number[] = []
    public row = 0
    public col = 0

    constructor(
        content: string = ''
    ) {
        this.contentSize = content.length
        this.content = content

        this.currElement = content.at(0);

        [...content.matchAll(/\n/g)].forEach(
            (row) => this.rows.push(row.index!)
        )
    }

    public inRange(): boolean {
        return this.cursor < this.content.length
    }

    public next(): boolean {
        this.currElement = this.content[++this.cursor]
        ++this.col

        const row = this.row + 0

        this.row = this.rows.reduce(
            (acc, row) => row < this.cursor ? acc + 1 : acc, 0
        )

        if (row !== this.row) this.col = 0

        return this.inRange()
    }

    public prev(): boolean {
        this.currElement = this.content[--this.cursor]
        --this.col

        const row = this.row + 0

        this.row = this.rows.reduce(
            (acc, row) => row < this.cursor ? acc + 1 : acc, 0
        )

        if (row !== this.row) this.col = 0

        return this.inRange()
    }
}

export { LexerScope, ParserScope, Scope }
